# Ed25519

Ed25519 is a state-of-the-art signature scheme using the Curve25519 elliptic curve with SHA-512 to hash messages. It offers exceptional performance, strong security guarantees, and resistance to implementation vulnerabilities.

## Overview

Ed25519 (Edwards-curve Digital Signature Algorithm) is based on the Ed25519 curve (a twisted Edwards curve equivalent to Curve25519). It's the preferred choice for modern cryptographic applications.

## Key Properties

- **Curve**: Curve25519 (Ed25519)
- **Hash function**: SHA-512
- **Secret key size**: 32 bytes
- **Public key size**: 32 bytes
- **Signature size**: 64 bytes
- **Security level**: 128 bits

## Usage

### Key Generation

```rust
use miden_crypto::dsa::eddsa_25519_sha512::{SecretKey, PublicKey};
use rand::rng;

// Generate with OS RNG (requires std feature)
let secret_key = SecretKey::new();

// Or with custom RNG (works in no_std)
let mut rng = rng();
let secret_key = SecretKey::with_rng(&mut rng);

// Get public key
let public_key = secret_key.public_key();
```

### Signing

```rust
use miden_crypto::{dsa::eddsa_25519_sha512::SecretKey, Word, Felt};

let message = Word::new([
    Felt::new(1),
    Felt::new(2),
    Felt::new(3),
    Felt::new(4),
]);

let signature = secret_key.sign(message);
```

### Verification

```rust
use miden_crypto::dsa::eddsa_25519_sha512::PublicKey;

let is_valid = public_key.verify(message, &signature);
assert!(is_valid);
```

### Key Commitment

Get a commitment to the public key:

```rust
let commitment = public_key.to_commitment();
```

## Serialization

### Secret Key

```rust
// Serialize
let bytes = secret_key.to_bytes();

// Deserialize
let secret_key = SecretKey::from_bytes(&bytes).unwrap();
```

### Public Key

```rust
// Serialize
let bytes = public_key.to_bytes();

// Deserialize
let public_key = PublicKey::from_bytes(&bytes).unwrap();
```

### Signature

```rust
// Serialize
let bytes = signature.to_bytes();

// Deserialize
let signature = Signature::from_bytes(&bytes).unwrap();
```

## Key Exchange

Ed25519 secret keys can be converted to X25519 for key exchange:

```rust
use miden_crypto::ecdh::x25519::EphemeralPublicKey;

// Get shared secret from ephemeral public key
let shared_secret = secret_key.get_shared_secret(ephemeral_pk);
```

## Advanced Features

### Challenge Hash Computation

For advanced use cases, you can compute the challenge hash separately:

```rust
let challenge_hash = public_key.compute_challenge_hash(message, &signature);
```

## Performance

Ed25519 is one of the fastest signature schemes available:

- **Signing**: Very fast
- **Verification**: Very fast
- **Key generation**: Fast

## Security Properties

- **Strong security**: 128-bit security level
- **Resistance to timing attacks**: Constant-time operations
- **Resistance to side-channel attacks**: Designed to resist implementation vulnerabilities
- **No signature malleability**: Deterministic signatures

## Use Cases

- Modern cryptographic applications
- High-performance systems
- Applications requiring strong security
- Systems where signature size matters (64 bytes vs 65 for ECDSA)

## Security Considerations

- **Randomness**: Always use a cryptographically secure RNG for key generation
- **Key storage**: Secret keys are automatically zeroized on drop
- **Deterministic**: Signatures are deterministic (same message + key = same signature)

## Related

- [ECDSA k256](ecdsa-k256.md): Ethereum-compatible alternative
- [RPO Falcon512](falcon512-rpo.md): Post-quantum alternative
- [Digital Signatures Overview](overview.md)

