searchState.loadedDescShard("p3_challenger", 0, "Utilities for generating Fiat-Shamir challenges based on …\nA generic trait for absorbing elements into the transcript.\nA trait for sampling challenge elements from the …\nA trait for sampling random bitstrings from the …\nUniform bit sampling interface.\nA generic duplex sponge challenger over a finite field, …\nA high-level trait combining observation and sampling over …\nTrait for challengers that support proof-of-work (PoW) …\nA generic challenger that uses a cryptographic hash …\nMaximum number of bits we can sample at negligible (~…\nA challenger that operates natively on PF but produces …\nCustom error raised when resampling is required for …\nAn array storing the largest value <code>m_k</code> for each <code>k</code> in [0, 31…\nGiven a challenger that can observe and sample bytes, …\nGiven a challenger that can observe and sample bytes, …\nTrait for challengers that support proof-of-work (PoW) …\nTrait for fields that support uniform bit sampling …\nThe underlying field element type used as the witness.\nCheck whether a given <code>witness</code> satisfies the PoW condition.\nCheck whether a given <code>witness</code> satisfies the PoW condition.\nCheck whether a given <code>witness</code> satisfies the PoW condition.\nCheck whether a given <code>witness</code> satisfies the PoW condition.\nCheck whether a given <code>witness</code> satisfies the PoW condition.\nCheck whether a given <code>witness</code> satisfies the PoW condition.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nPerform a brute-force search to find a valid PoW witness.\nGrinds based on <em>uniformly sampled bits</em>. This variant is …\nGrinds based on <em>uniformly sampled bits</em>. This variant …\nA buffer holding field elements that have been observed …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAbsorb a single value into the transcript.\nAbsorb an element from a vector space over the base field.\nAbsorb a slice of elements from a vector space over the …\nObserve base field elements as extension field elements …\nAbsorb a slice of values into the transcript.\nA buffer holding field elements that have been squeezed …\nThe cryptographic permutation applied to the sponge state.\nSample a single challenge value from the transcript.\nSample an element of a vector space over the base field.\nSample an array of <code>N</code> challenge values from the transcript.\nSample a random <code>bits</code>-bit integer from the transcript.\nThe sampled bits are not perfectly uniform, but we can …\nThe sampled bits are not perfectly uniform, but we can …\nSample a random <code>bits</code>-bit integer from the transcript with …\nSample a <code>Vec</code> of <code>n</code> challenge values from the transcript.\nThe internal sponge state, consisting of <code>WIDTH</code> field …")