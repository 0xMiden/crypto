searchState.loadedDescShard("p3_field", 0, "A framework for finite fields.\nA ring <code>R</code> implements <code>Algebra&lt;F&gt;</code> if there is an injective …\nA vector space <code>V</code> over <code>F</code> with a fixed basis. Fixing the …\nSame as <code>Powers</code>, but returns a bounded number of powers.\nThe dimension of the vector space, i.e. the number of …\nA field <code>EF</code> which is also an algebra over a field <code>F</code>.\nA field <code>F</code>. This permits both modular fields <code>ℤ/p</code> along …\nA generator of this field’s multiplicative group.\nA ring implements <code>InjectiveMonomial&lt;N&gt;</code> if the algebraic …\nThe element in the ring given by <code>-ONE</code>.\nThe number of bytes which this field element occupies in …\nThe multiplicative identity of the ring.\nA trait to constrain types that can be packed into a …\nAn array of field elements which can be packed into a …\nFix a field <code>F</code> a packing width <code>W</code> and an extension field <code>EF</code> …\nSafety\nA trait for array-like structs made up of multiple scalar …\nA ring implements <code>PermutationMonomial&lt;N&gt;</code> if the algebraic …\nAn iterator which returns the powers of a base element <code>b</code> …\nA commutative ring, <code>R</code>, with prime characteristic, <code>p</code>.\nA field isomorphic to <code>ℤ/p</code> for some prime <code>p</code>.\nA prime field <code>ℤ/p</code> with order <code>p &lt; 2^32</code>.\nA prime field <code>ℤ/p</code> with order, <code>p &lt; 2^64</code>.\nThe field <code>ℤ/p</code> where the characteristic of this ring is p.\nA collection of methods designed to help hash field …\nThe element in the ring given by <code>ONE + ONE</code>.\nThe number of factors of two in this field’s …\nA field which supplies information like the two-adicity of …\nThe scalar type that is packed into this value.\nNumber of scalar values packed together.\nThe additive identity of the ring.\nAdds <code>other</code>, scaled by <code>s</code>, to the mutable <code>slice</code> using …\nAdd two slices of field elements together, returning the …\nAdd two slices of field elements together, returning the …\nComputes the arithmetic generalization of <code>andnot</code>.\nComputes the arithmetic generalization of <code>andnot</code>.\nIf the element lies in the base field project it down. …\nFixes a basis for the algebra <code>A</code> and uses this to map an …\nReturn the representative of <code>value</code> in canonical form which …\nReturn the representative of <code>value</code> in canonical form which …\nReturn the representative of <code>value</code> in canonical form which …\nView as a slice of raw <code>[F; N]</code> arrays.\nView as a mutable slice of raw <code>[F; N]</code> arrays.\nReturns the underlying scalar values as an immutable slice.\nReturns the underlying scalar values as a mutable slice.\nBatch multiplicative inverses with Montgomery’s trick …\nThe number of bits required to define an element of this …\nThe number of bits required to define an element of this …\nThe vanishing polynomial for boolean values: <code>x * (x - 1)</code>.\nThe vanishing polynomial for boolean values: <code>x * (x - 1)</code>.\nCollect exactly <code>num_powers</code> ascending powers of <code>self.base</code>, …\nWrapper for <code>self.take(n).collect()</code>.\nThe elementary function <code>cube(a) = a^3</code>.\nThe elementary function <code>cube(a) = a^3</code>.\nComputes a coset of a multiplicative subgroup whose order …\nComputes a multiplicative subgroup whose order is known in …\nDivide by a given power of two. …\nDivide by a given power of two. …\nMaximally generic dot product.\nCompute the dot product of two vectors.\nCompute the dot product of two vectors.\nThe elementary function <code>double(a) = 2*a</code>.\nThe elementary function <code>double(a) = 2*a</code>.\nExponentiation by a small constant power.\nExponentiation by a small constant power.\nThe elementary function …\nThe elementary function …\nExponentiation by a <code>u64</code> power.\nExponentiation by a <code>u64</code> power.\nExtract the scalar value at the given SIMD lane.\nExtract the scalar value at the given SIMD lane.\nExtract the extension field element at the given SIMD lane.\nExtract the extension field element at the given SIMD lane.\nExtend a ring <code>R</code> element <code>x</code> to an array of length <code>D</code> by …\nFills <code>slice</code> with the next <code>slice.len()</code> powers yielded by …\nConvert from a vector of <code>Self</code> to a vector of <code>F</code> by …\nConvert from a vector of <code>Self</code> to a vector of <code>F</code> by …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFixes a basis for the algebra <code>A</code> and uses this to map …\nFixes a basis for the algebra <code>A</code> and uses this to map …\nFixes a basis for the algebra <code>A</code> and uses this to map …\nFixes a basis for the algebra <code>A</code> and uses this to map …\nReturn <code>Self::ONE</code> if <code>b</code> is <code>true</code> and <code>Self::ZERO</code> if <code>b</code> is <code>false</code>.\nReturn <code>Self::ONE</code> if <code>b</code> is <code>true</code> and <code>Self::ZERO</code> if <code>b</code> is <code>false</code>.\nGiven a slice of extension field <code>EF</code> elements of length <code>W</code>, …\nConstructs a packed value using a function to generate …\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nEmbed an element of the prime field <code>ℤ/p</code> into the ring <code>R</code>.\nReinterpret a slice of <code>[F; N]</code> as a slice of …\nReinterpret a mutable slice of <code>[F; N]</code> as a mutable slice …\nInterprets a slice of scalar values as a packed value …\nInterprets a mutable slice of scalar values as a mutable …\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nGiven an integer <code>r</code>, return the sum of <code>r</code> copies of <code>ONE</code>:\nThe elementary function <code>halve(a) = a/2</code>.\nThe elementary function <code>halve(a) = a/2</code>.\nGiven an element x from a 32 bit field F_P compute x/2.\nGiven an element x from a 64 bit field F_P compute x/2.\nGiven a struct which implements <code>Add</code> implement <code>AddAssign&lt;T&gt;</code> …\nGiven two structs <code>Alg</code> and <code>Field</code> where <code>Alg</code> implements …\nGiven two structs <code>Alg</code> and <code>Field</code> where <code>Alg</code> implements …\nGiven two structs <code>Alg</code> and <code>Field</code> where <code>Alg</code> implements …\nGiven a struct which implements <code>Mul</code> implement <code>MulAssign&lt;T&gt;</code> …\nA macro to implement the PackedFieldPow2 trait for …\nA macro to implement the PackedFieldPow2 trait for …\nGiven <code>Field</code> and <code>Algebra</code> structs where <code>Algebra</code> is simply a …\nA simple macro which allows us to implement the …\nA simple macro which allows us to implement the …\nGiven a struct <code>Alg</code> which is a wrapper over <code>[Field; N]</code> for …\nGiven a struct which implements <code>Sub</code> implement <code>SubAssign&lt;T&gt;</code> …\nGiven two structs <code>Alg</code> and <code>Field</code> where <code>Alg</code> implements …\nGiven two structs <code>Alg</code> and <code>Field</code> where <code>Alg</code> implements …\nCompute <code>x -&gt; x^n</code> for a given <code>n &gt; 1</code> such that this map is …\nCompute <code>x -&gt; x^n</code> for a given <code>n &gt; 1</code> such that this map is …\nCompute <code>x -&gt; x^K</code> for a given <code>K &gt; 1</code> such that <code>x^{NK} = x</code> …\nA collection of traits and macros which convert primitive …\nTake interpret two vectors as chunks of <code>block_len</code> …\nA file containing a collection of architecture-specific …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert an iterator of field elements into an iterator of …\nConvert an iterator of field elements into an iterator of …\nConvert a field element into a collection of bytes.\nConvert an iterator of field element arrays into an …\nConvert an iterator of field element arrays into an …\nConvert an iterator of field element arrays into an …\nConvert an iterator of field element arrays into an …\nConvert an iterator of field element arrays into an …\nConvert an iterator of field element arrays into an …\nConvert an iterator of field elements into an iterator of …\nConvert an iterator of field elements into an iterator of …\nConvert an iterator of field elements into an iterator of …\nConvert an iterator of field elements into an iterator of …\nThe multiplicative inverse of this field element.\nThe multiplicative inverse of this field element.\nDetermine if the given element lies in the base field.\nCheck if the given field element is equal to the unique …\nCheck if the given field element is equal to the unique …\nCheck if the given field element is equal to the unique …\nCheck if the given field element is equal to the unique …\nGiven a basis for the Algebra <code>A</code>, return the i’th basis …\nGiven a basis for the Algebra <code>A</code>, return the i’th basis …\nApply a function to each element, returning a new …\nApply a function to each element, returning a raw array …\nThe elementary function <code>mul_2exp_u64(a, exp) = a * 2^{exp}</code>.\nThe elementary function <code>mul_2exp_u64(a, exp) = a * 2^{exp}</code>.\nA collection of macros designed to implement simple …\nThe number of elements in the field.\nConverts a mutable slice of possibly uninitialized scalar …\nConverts a mutable slice of possibly uninitialized scalar …\nConverts a mutable slice of possibly uninitialized scalar …\nConverts a mutable slice of possibly uninitialized scalar …\nPacks a slice of scalar values into a slice of packed …\nPacks a slice of scalar values into a slice of packed …\nConverts a mutable slice of scalar values into a mutable …\nConverts a mutable slice of scalar values into a mutable …\nPacks a slice into packed values and returns the packed …\nPacks a slice into packed values and returns the packed …\nConverts a mutable slice of scalar values into a pair:\nConverts a mutable slice of scalar values into a pair:\nSimilar to <code>packed_powers</code>, construct an iterator which …\nSimilar to <code>packed_ext_powers</code> but only returns <code>unpacked_len</code> …\nSimilar to <code>packed_ext_powers</code> but only returns <code>unpacked_len</code> …\nCompute a linear combination of a slice of base field …\nCompute a linear combination of a slice of base field …\nAdd two arrays of integers modulo <code>P</code> using packing.\nSubtract two arrays of integers modulo <code>P</code> using packing.\nConstruct an iterator which returns powers of <code>base</code> packed …\nConstruct an iterator which returns powers of <code>base</code> packed …\nConstruct an iterator which returns powers of <code>base</code> …\nConstruct an iterator which returns powers of <code>base</code> …\nAdds <code>other</code>, scaled by <code>s</code>, to the mutable <code>slice</code> using …\nScales each element of the slice by <code>s</code> using packing and …\nConstruct an iterator which returns powers of <code>self</code>: …\nConstruct an iterator which returns powers of <code>self</code>: …\nFor large signed integer types, a simple method which is …\nIf the unsigned integer type is large enough, there is …\nIf the integer type is smaller than the field order all …\nThis allows us to avoid some duplication which arises when …\nConvert from a vector of <code>F</code> to a vector of <code>Self</code> by …\nConvert from a vector of <code>F</code> to a vector of <code>Self</code> by …\nReduce a slice of 32-bit field elements into a single …\nGiven a struct which implements <code>Add</code> implement <code>Sum</code>.\nThis function is deprecated. It is currently a wrapper for …\nScales each element of the slice by <code>s</code> using packing.\nConstruct an iterator which returns powers of <code>self</code> shifted …\nConstruct an iterator which returns powers of <code>self</code> shifted …\nSplit a large field element into <code>n</code> base-$2^{64}$ chunks …\nThe elementary function <code>square(a) = a^2</code>.\nThe elementary function <code>square(a) = a^2</code>.\nCompute the sum of a slice of elements whose length is a …\nCompute the sum of a slice of elements whose length is a …\nReturns an iterator yielding the first <code>n</code> powers.\nConvert an iterator of packed extension field elements to …\nConvert an iterator of packed extension field elements to …\nConvert a field element to a <code>u32</code> such that any two field …\nConvert a field element to a <code>u32</code> such that any two field …\nConvert a field element to a <code>u64</code> such that any two field …\nConvert a field element to a <code>u64</code> such that any two field …\nThe multiplicative inverse of this field element, if it …\nReturns a generator of the multiplicative group of order …\nUnpack <code>N</code> packed values into <code>WIDTH</code> rows of <code>N</code> scalars.\nUnpack <code>N</code> packed values into <code>WIDTH</code> rows of <code>N</code> scalars.\nReinterprets a slice of packed values as a flat slice of …\nReinterprets a slice of packed values as a flat slice of …\nComputes the arithmetic generalization of boolean <code>xor</code>.\nComputes the arithmetic generalization of boolean <code>xor</code>.\nComputes the arithmetic generalization of a triple <code>xor</code>.\nComputes the arithmetic generalization of a triple <code>xor</code>.\nAllocates a vector of zero elements of length <code>len</code>. Many …\nAllocates a vector of zero elements of length <code>len</code>. Many …\nCoset of a subgroup of the group of units of a finite …\nChecks if the given field element is in the coset\nReturns the element <code>shift * generator^index</code>, which is the …\nReturns the coset <code>self^(2^log_scale_factor)</code> (i. e. with …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns an iterator over the elements of the coset in the …\nReturns the log2 of the size of the coset.\nReturns the coset <code>shift * &lt;generator&gt;</code>, where <code>generator</code> is a\nReturns a new coset where the shift has been set to <code>shift</code>\nReturns the shift of the coset.\nReturns a new coset of the same size whose shift is equal …\nReturns the inverse of the coset shift.\nReturns a new coset with its subgroup reduced by a factor …\nReturns the size of the coset.\nReturns the generator of the subgroup of order <code>self.size()</code>.\nCompute the exponential <code>x -&gt; x^10540996611094048183</code> using …\nCompute the exponential <code>x -&gt; x^1420470955</code> using a custom …\nCompute the exponential <code>x -&gt; x^1717986917</code> using a custom …\nCompute the exponential <code>x -&gt; x^1725656503</code> using a custom …\nTrait for fields that support binomial extension of the …\nTrait for algebras which support binomial extensions of …\nThe two-adicity of <code>p+1</code>, the order of the circle group.\nA field for which <code>p = 3 (mod 4)</code>. Equivalently, <code>-1</code> is not a …\nA <code>D</code>-th root of unity derived from <code>W</code>.\nA generator for the extension field, expressed as a degree-…\nTwo-adicity of the multiplicative group of the extension …\nThe complex extension of this field has a binomial …\nTrait for extension fields that support Frobenius …\nTrait for binomial extensions that support a two-adic …\nThe complex extension of this field has a two-adic …\nThe constant coefficient <code>W</code> in the binomial <code>X^D - W</code>.\nAddition of elements in the algebra extension ring …\nMultiplication in the algebra extension ring …\nSubtraction of elements in the algebra extension ring …\nReturns a two-adic generator for the extension field.\nApply the Frobenius automorphism once.\nFrobeniusField automorphisms: x -&gt; x^n, where n is the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the full Galois orbit of the element under …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate an extension field element from an array of base …\nConvert a <code>[[F; D]; N]</code> array to an array of extension field …\nMultiplication in an octic binomial extension field.\nComputes the pseudo inverse of the given field element.\nCompute the pseudo inverse of a given element making use …\nMultiplication in a quartic binomial extension field.\nMultiplication in a quintic binomial extension field.\nApply the Frobenius automorphism <code>count</code> times.\nRepeated Frobenius automorphisms: x -&gt; x^(n^count).\nAdd two vectors element wise.\nImplementation of the quotient map <code>ℤ -&gt; ℤ/p</code> which …\nConvert a given integer into an element of the field <code>ℤ/p</code>…\nConvert a given integer into an element of the field <code>ℤ/p</code>…\nConvert a given integer into an element of the field <code>ℤ/p</code>.\nA macro to implement the PackedFieldPow2 trait for …\nGiven a struct which implements <code>Add</code> implement <code>AddAssign&lt;T&gt;</code> …\nGiven two structs <code>Alg</code> and <code>Field</code> where <code>Alg</code> implements …\nGiven two structs <code>Alg</code> and <code>Field</code> where <code>Alg</code> implements …\nGiven two structs <code>Alg</code> and <code>Field</code> where <code>Alg</code> implements …\nGiven a struct which implements <code>Mul</code> implement <code>MulAssign&lt;T&gt;</code> …\nGiven <code>Field</code> and <code>Algebra</code> structs where <code>Algebra</code> is simply a …\nGiven a struct <code>Alg</code> which is a wrapper over <code>[Field; N]</code> for …\nGiven a struct which implements <code>Sub</code> implement <code>SubAssign&lt;T&gt;</code> …\nGiven two structs <code>Alg</code> and <code>Field</code> where <code>Alg</code> implements …\nGiven two structs <code>Alg</code> and <code>Field</code> where <code>Alg</code> implements …\nGiven a struct which implements <code>Add</code> implement <code>Sum</code>.")