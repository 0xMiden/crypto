use alloc::{string::ToString, vec::Vec};

use miden_crypto_derive::{SilentDebug, SilentDisplay};
use num::Complex;
use num_complex::Complex64;
use rand::Rng;

use super::{
    super::{
        ByteReader, ByteWriter, Deserializable, DeserializationError, MODULUS, N, Nonce,
        SIG_L2_BOUND, SIGMA, Serializable, ShortLatticeBasis, Signature,
        math::{FalconFelt, FastFft, LdlTree, Polynomial, ffldl, flr::FLR, gram, normalize_tree},
        signature::SignaturePoly,
    },
    PublicKey,
};
use crate::{
    Word,
    dsa::falcon512_rpo::{LOG_N, SK_LEN, hash_to_point::hash_to_point_rpo256, math::ntru_gen},
    hash::blake::Blake3_256,
    utils::zeroize::{Zeroize, ZeroizeOnDrop},
};

// CONSTANTS
// ================================================================================================

pub(crate) const WIDTH_BIG_POLY_COEFFICIENT: usize = 8;
pub(crate) const WIDTH_SMALL_POLY_COEFFICIENT: usize = 6;

// RNG ADAPTER
// ================================================================================================

use super::super::math::sampler_flr::SamplerRng;

/// Adapter to make a `Rng` compatible with `SamplerRng` trait.
struct RngAdapter<R: Rng> {
    rng: R,
}

impl<R: Rng> SamplerRng for RngAdapter<R> {
    fn next_u8(&mut self) -> u8 {
        // Use fill_bytes to get exactly 1 byte efficiently
        // (random::<u8>() would call next_u32() and waste 3 bytes)
        let mut buf = [0u8; 1];
        self.rng.fill_bytes(&mut buf);
        buf[0]
    }

    fn next_u64(&mut self) -> u64 {
        // Use fill_bytes to get exactly 8 bytes efficiently
        let mut buf = [0u8; 8];
        self.rng.fill_bytes(&mut buf);
        u64::from_le_bytes(buf)
    }
}

// SECRET KEY
// ================================================================================================

/// Represents the secret key for Falcon DSA.
///
/// The secret key is stored internally as a quadruple [g, f, G, F] of polynomials with integer
/// coefficients. During signing, this is transformed to the signing basis [[g, -f], [G, -F]] where
/// negations are applied. Each polynomial is of degree at most N = 512 and computations with these
/// polynomials is done modulo the monic irreducible polynomial ϕ = x^N + 1. The secret key is a
/// basis for a lattice and has the property of being short with respect to a certain norm and an
/// upper bound appropriate for a given security parameter. The public key on the other hand is
/// another basis for the same lattice and can be described by a single polynomial h with integer
/// coefficients modulo ϕ. The two keys are related by the following relation:
///
/// 1. h = g /f [mod ϕ][mod p]
/// 2. f.G - g.F = p [mod ϕ]
///
/// where p = 12289 is the Falcon prime. Equation 2 is called the NTRU equation.
/// The secret key is generated by first sampling a random pair (f, g) of polynomials using
/// an appropriate distribution that yields short but not too short polynomials with integer
/// coefficients modulo ϕ. The NTRU equation is then used to find a matching pair (F, G).
/// The public key is then derived from the secret key using equation 1.
///
/// To allow for fast signature generation, the secret key is pre-processed into a more suitable
/// form, called the LDL tree, and this allows for fast sampling of short vectors in the lattice
/// using Fast Fourier sampling during signature generation (ffSampling algorithm 11 in [1]).
///
/// [1]: https://falcon-sign.info/falcon.pdf
#[derive(Clone, SilentDebug, SilentDisplay)]
pub struct SecretKey {
    secret_key: ShortLatticeBasis,
    tree: LdlTree,
    /// Precomputed basis B = [[g, -f], [G, -F]] in FFT format using FLR arithmetic.
    /// This is used for fast signing with the FLR-based sampler.
    /// Layout: [b00, b01, b10, b11] where each is N FLR values in FFT domain.
    basis_fft_flr: [FLR; 4 * N],
}

impl Zeroize for SecretKey {
    fn zeroize(&mut self) {
        self.secret_key.zeroize();
        self.tree.zeroize();
        // Manually zeroize FLR array
        for i in 0..self.basis_fft_flr.len() {
            self.basis_fft_flr[i] = FLR::ZERO;
        }
    }
}

// Manual Drop implementation to ensure zeroization on drop.
// Cannot use #[derive(ZeroizeOnDrop)] because it's not available when sourcing zeroize from k256.
impl Drop for SecretKey {
    fn drop(&mut self) {
        self.zeroize();
    }
}

impl ZeroizeOnDrop for SecretKey {}

#[allow(clippy::new_without_default)]
impl SecretKey {
    // CONSTRUCTORS
    // --------------------------------------------------------------------------------------------

    /// Generates a secret key from OS-provided randomness.
    #[cfg(feature = "std")]
    pub fn new() -> Self {
        let mut rng = rand::rng();
        Self::with_rng(&mut rng)
    }

    /// Generates a secret_key using the provided random number generator `Rng`.
    pub fn with_rng<R: Rng>(rng: &mut R) -> Self {
        let basis = ntru_gen(N, rng);
        Self::from_short_lattice_basis(basis)
    }

    /// Generates a secret key using the provided random number generator with fn-dsa-compatible
    /// key generation.
    ///
    /// This method uses the reference fn-dsa-kgen algorithms and has been validated to produce
    /// identical keys to the reference implementation when given the same seed.
    pub fn with_rng_fndsa<R: Rng>(rng: &mut R) -> Self {
        use crate::dsa::falcon512_rpo::math::ntru_gen_opt_fndsa;
        use fn_dsa_comm::PRNG;

        // we use fn-dsa's SHAKE256_PRNG seeded with `rng`
        // this is a work around the fact that the version of the `rand` dependency in our crate
        // is different than the one used in the `fn-dsa` crates
        let mut seed = [0u8; 32];
        rng.fill_bytes(&mut seed);
        let mut prng = <fn_dsa_comm::shake::SHAKE256_PRNG as PRNG>::new(&seed);

        let basis = ntru_gen_opt_fndsa(N, &mut prng);

        // Zeroize the seed to prevent leaking secret material
        seed.zeroize();

        Self::from_short_lattice_basis(basis)
    }

    /// Given a short basis [g, f, G, F], computes the normalized LDL tree i.e., Falcon tree.
    /// Note: The basis is stored as [g, f, G, F]; negations to form [[g, -f], [G, -F]] are
    /// applied in to_complex_fft.
    pub(crate) fn from_short_lattice_basis(basis: ShortLatticeBasis) -> SecretKey {
        // FFT each polynomial of the short basis for Complex64 LDL tree
        // to_complex_fft returns [FFT(g), FFT(-f), FFT(G), FFT(-F)] for signing basis
        let basis_fft = to_complex_fft(&basis);

        // compute the Gram matrix for the signing basis [[g, -f], [G, -F]]
        let gram_fft = gram(basis_fft);
        // construct the LDL tree of the Gram matrix.
        let mut tree = ffldl(gram_fft);
        // normalize the leaves of the LDL tree.
        normalize_tree(&mut tree, SIGMA);

        // Precompute FLR basis in FFT format for fast signing
        let basis_fft_flr = Self::compute_basis_fft_flr(&basis);

        Self { secret_key: basis, tree, basis_fft_flr }
    }

    // PUBLIC ACCESSORS
    // --------------------------------------------------------------------------------------------

    /// Returns the polynomials of the short lattice basis of this secret key.
    pub fn short_lattice_basis(&self) -> &ShortLatticeBasis {
        &self.secret_key
    }

    /// Returns the public key corresponding to this secret key.
    pub fn public_key(&self) -> PublicKey {
        self.compute_pub_key_poly()
    }

    /// Returns the LDL tree associated to this secret key.
    pub fn tree(&self) -> &LdlTree {
        &self.tree
    }

    // SIGNATURE GENERATION
    // --------------------------------------------------------------------------------------------

    /// Signs a message with this secret key.
    pub fn sign(&self, message: crate::Word) -> Signature {
        use rand::SeedableRng;
        use rand_chacha::ChaCha20Rng;

        let mut seed = self.generate_seed(&message);
        let mut rng = ChaCha20Rng::from_seed(seed);
        let signature = self.sign_with_rng(message, &mut rng);

        // Zeroize the seed to prevent leakage
        seed.zeroize();

        signature
    }

    /// Signs a message with the secret key relying on the provided randomness generator.
    pub fn sign_with_rng<R: Rng>(&self, message: Word, rng: &mut R) -> Signature {
        let nonce = Nonce::deterministic();

        let h = self.compute_pub_key_poly();
        let c = hash_to_point_rpo256(message, &nonce);
        let s2 = self.sign_helper(c, rng);

        Signature::new(nonce, h, s2)
    }

    /// Signs a message with the secret key relying on the provided randomness generator.
    ///
    /// This is similar to [SecretKey::sign_with_rng()] and is used only for testing with
    /// the main difference being that this method:
    ///
    /// 1. uses `SHAKE256` for the hash-to-point algorithm, and
    /// 2. uses `ChaCha20` in `Self::sign_helper`.
    ///
    /// Hence, in contrast to `Self::sign_with_rng`, the current method uses different random
    /// number generators for generating the nonce and in `Self::sign_helper`.
    ///
    /// These changes make the signature algorithm compliant with the reference implementation.
    #[cfg(test)]
    pub fn sign_with_rng_testing<R: Rng>(&self, message: &[u8], rng: &mut R) -> Signature {
        use crate::dsa::falcon512_rpo::{hash_to_point::hash_to_point_shake256, tests::ChaCha};

        let nonce = Nonce::random(rng);

        let h = self.compute_pub_key_poly();
        let c = hash_to_point_shake256(message, &nonce);

        let mut chacha_prng = ChaCha::new(rng);
        let s2 = self.sign_helper(c, &mut chacha_prng);

        Signature::new(nonce, h, s2)
    }

    // HELPER METHODS
    // --------------------------------------------------------------------------------------------

    /// Derives the public key corresponding to this secret key using h = g /f [mod ϕ][mod p].
    fn compute_pub_key_poly(&self) -> PublicKey {
        let g: Polynomial<FalconFelt> = self.secret_key[0].clone().into();
        let g_fft = g.fft();
        let f: Polynomial<FalconFelt> = self.secret_key[1].clone().into();
        let f_fft = f.fft();
        let h_fft = g_fft.hadamard_div(&f_fft);
        h_fft.ifft().into()
    }

    /// Signs a message polynomial with the secret key using FLR-based ffsampling.
    ///
    /// This implementation uses Fixed-point Linear Real (FLR) arithmetic ported from
    /// rust-fn-dsa. It provides deterministic, no_std compatible signing without requiring
    /// floating-point hardware. The sampler uses a Gram matrix instead of the LDL tree.
    ///
    /// Takes a randomness generator implementing `Rng` and message polynomial representing `c`
    /// the hash-to-point of the message to be signed. It outputs a signature polynomial `s2`.
    fn sign_helper<R: Rng>(&self, c: Polynomial<FalconFelt>, rng: &mut R) -> SignaturePoly {
        self.sign_helper_flr(c, rng)
    }

    #[cfg(test)]
    pub(crate) fn sign_helper_legacy<R: Rng>(
        &self,
        c: Polynomial<FalconFelt>,
        rng: &mut R,
    ) -> SignaturePoly {
        use super::super::math::ffsampling;

        let one_over_q = 1.0 / (MODULUS as f64);
        let c_over_q_fft = c.map(|cc| Complex::new(one_over_q * cc.value() as f64, 0.0)).fft();

        // B = [[FFT(g), -FFT(f)], [FFT(G), -FFT(F)]]
        let [g_fft, minus_f_fft, big_g_fft, minus_big_f_fft] = to_complex_fft(&self.secret_key);
        let t0 = c_over_q_fft.hadamard_mul(&minus_big_f_fft);
        let t1 = -c_over_q_fft.hadamard_mul(&minus_f_fft);

        loop {
            let bold_s = loop {
                let z = ffsampling(&(t0.clone(), t1.clone()), &self.tree, rng);
                let t0_min_z0 = t0.clone() - z.0;
                let t1_min_z1 = t1.clone() - z.1;

                // s = (t-z) * B
                let s0 = t0_min_z0.hadamard_mul(&g_fft) + t1_min_z1.hadamard_mul(&big_g_fft);
                let s1 =
                    t0_min_z0.hadamard_mul(&minus_f_fft) + t1_min_z1.hadamard_mul(&minus_big_f_fft);

                // compute the norm of (s0||s1) and note that they are in FFT representation
                let length_squared: f64 =
                    (s0.coefficients.iter().map(|a| (a * a.conj()).re).sum::<f64>()
                        + s1.coefficients.iter().map(|a| (a * a.conj()).re).sum::<f64>())
                        / (N as f64);

                if length_squared > (SIG_L2_BOUND as f64) {
                    continue;
                }

                break [-s0, s1];
            };

            let s2 = bold_s[1].ifft();
            let s2_coef: [i16; N] = s2
                .coefficients
                .iter()
                .map(|a| a.re.round() as i16)
                .collect::<Vec<i16>>()
                .try_into()
                .expect("The number of coefficients should be equal to N");

            if let Ok(s2) = SignaturePoly::try_from(&s2_coef) {
                return s2;
            }
        }
    }

    /// Computes the FLR basis B = [[g, -f], [G, -F]] in FFT format.
    /// Returns an array [b00, b01, b10, b11] where each is N FLR values in FFT domain.
    /// This follows fn-dsa's compute_basis_inner approach for precomputation during keygen.
    fn compute_basis_fft_flr(basis: &ShortLatticeBasis) -> [FLR; 4 * N] {
        use super::super::math::poly_flr::{FFT, poly_set_small};
        use core::array;
        const LOGN_U32: u32 = LOG_N as u32;

        // Convert i16 basis to i8 for poly_set_small
        let basis_i8: [[i8; N]; 4] = [
            array::from_fn(|i| basis[0].coefficients[i] as i8),
            array::from_fn(|i| basis[1].coefficients[i] as i8),
            array::from_fn(|i| basis[2].coefficients[i] as i8),
            array::from_fn(|i| basis[3].coefficients[i] as i8),
        ];

        let mut result = [FLR::ZERO; 4 * N];

        // Split result into b00, b01, b10, b11
        let (b00, rest) = result.split_at_mut(N);
        let (b01, rest) = rest.split_at_mut(N);
        let (b10, rest) = rest.split_at_mut(N);
        let (b11, _) = rest.split_at_mut(N);

        // Load basis: stored as B = [[g, f], [G, F]]
        poly_set_small(LOGN_U32, b00, &basis_i8[0]); // g
        poly_set_small(LOGN_U32, b01, &basis_i8[1]); // f
        poly_set_small(LOGN_U32, b10, &basis_i8[2]); // G
        poly_set_small(LOGN_U32, b11, &basis_i8[3]); // F

        // Transform to FFT domain
        FFT(LOGN_U32, b00);
        FFT(LOGN_U32, b01);
        FFT(LOGN_U32, b10);
        FFT(LOGN_U32, b11);

        // Negate f and F in FFT domain to get signing basis B = [[g, -f], [G, -F]]
        // (matches fn-dsa-sign's compute_basis_inner)
        for i in 0..N {
            b01[i] = -b01[i];
            b11[i] = -b11[i];
        }

        result
    }

    pub(crate) fn sign_helper_flr<R: Rng>(
        &self,
        c: Polynomial<FalconFelt>,
        rng: &mut R,
    ) -> SignaturePoly {
        use super::super::math::poly_flr::{
            FFT, iFFT, poly_add, poly_mul_fft, poly_muladj_fft, poly_mulconst, poly_mulownadj_fft,
        };
        use super::super::math::sampler_flr::Sampler;
        const LOGN_U32: u32 = LOG_N as u32;

        // Use precomputed FFT basis B = [[g, -f], [G, -F]]
        // Layout: [b00, b01, b10, b11] where b01 and b11 are already negated
        let b00 = &self.basis_fft_flr[0..N]; // g in FFT
        let b01 = &self.basis_fft_flr[N..2 * N]; // -f in FFT
        let b10 = &self.basis_fft_flr[2 * N..3 * N]; // G in FFT
        let b11 = &self.basis_fft_flr[3 * N..4 * N]; // -F in FFT

        // Compute Gram matrix G = B^H * B from precomputed FFT basis
        // This is much faster than computing from scratch (6 muls vs 4 FFTs + 6 muls)
        let mut g00 = [FLR::ZERO; N];
        let mut g01 = [FLR::ZERO; N];
        let mut g11 = [FLR::ZERO; N];
        let mut temp = [FLR::ZERO; N];

        // g00 = b00*adj(b00) + b01*adj(b01)
        g00.copy_from_slice(b00);
        poly_mulownadj_fft(LOGN_U32, &mut g00);
        temp.copy_from_slice(b01);
        poly_mulownadj_fft(LOGN_U32, &mut temp);
        poly_add(LOGN_U32, &mut g00, &temp);

        // g01 = b00*adj(b10) + b01*adj(b11)
        g01.copy_from_slice(b00);
        poly_muladj_fft(LOGN_U32, &mut g01, b10);
        temp.copy_from_slice(b01);
        poly_muladj_fft(LOGN_U32, &mut temp, b11);
        poly_add(LOGN_U32, &mut g01, &temp);

        // g11 = b10*adj(b10) + b11*adj(b11)
        g11.copy_from_slice(b10);
        poly_mulownadj_fft(LOGN_U32, &mut g11);
        temp.copy_from_slice(b11);
        poly_mulownadj_fft(LOGN_U32, &mut temp);
        poly_add(LOGN_U32, &mut g11, &temp);

        // Convert hash-to-point polynomial c to FLR and transform to FFT domain
        let mut c_fft = [FLR::ZERO; N];
        for i in 0..N {
            c_fft[i] = FLR::from_i32(c.coefficients[i].value() as i32);
        }
        FFT(LOGN_U32, &mut c_fft);

        // Compute target vectors: t0 = -(c/q) * F, t1 = (c/q) * f
        // Note: b11 = -F and b01 = -f from precomputed basis
        let one_over_q = FLR::from_f64(1.0 / (MODULUS as f64));
        let mut t0 = c_fft;
        let mut t1 = c_fft;

        // t0 = (c/q) * b11 = (c/q) * (-F) = -(c/q) * F ✓
        poly_mulconst(LOGN_U32, &mut t0, one_over_q);
        let mut b11_copy = [FLR::ZERO; N];
        b11_copy.copy_from_slice(b11);
        poly_mul_fft(LOGN_U32, &mut t0, &b11_copy);

        // t1 = -(c/q) * b01 = -(c/q) * (-f) = (c/q) * f ✓
        poly_mulconst(LOGN_U32, &mut t1, one_over_q);
        let mut b01_copy = [FLR::ZERO; N];
        b01_copy.copy_from_slice(b01);
        poly_mul_fft(LOGN_U32, &mut t1, &b01_copy);
        for i in 0..N {
            t1[i] = -t1[i];
        }

        // Create sampler with RNG adapter
        let rng_adapter = RngAdapter { rng };
        let mut sampler = Sampler::new(rng_adapter, LOGN_U32);
        let mut tmp = vec![FLR::ZERO; 4 * N];

        loop {
            let bold_s = loop {
                // Clone Gram matrix for this iteration
                let mut g00_work = g00;
                let mut g01_work = g01;
                let mut g11_work = g11;

                // Sample z from discrete Gaussian using Gram matrix
                let mut t0_work = t0;
                let mut t1_work = t1;
                sampler.ffsamp_fft(
                    &mut t0_work,
                    &mut t1_work,
                    &mut g00_work,
                    &mut g01_work,
                    &mut g11_work,
                    &mut tmp,
                );

                // Compute t - z
                let mut t0_min_z0 = t0;
                let mut t1_min_z1 = t1;
                for i in 0..N {
                    t0_min_z0[i] -= t0_work[i];
                    t1_min_z1[i] -= t1_work[i];
                }

                // Compute s = (t - z) * B where B = [[g, -f], [G, -F]]
                // s0 = (t0-z0) * g + (t1-z1) * G
                let mut s0 = t0_min_z0;
                let mut b00_copy = [FLR::ZERO; N];
                b00_copy.copy_from_slice(b00);
                poly_mul_fft(LOGN_U32, &mut s0, &b00_copy);
                let mut temp = t1_min_z1;
                let mut b10_copy = [FLR::ZERO; N];
                b10_copy.copy_from_slice(b10);
                poly_mul_fft(LOGN_U32, &mut temp, &b10_copy);
                poly_add(LOGN_U32, &mut s0, &temp);

                // s1 = (t0-z0) * (-f) + (t1-z1) * (-F) = (t0-z0) * b01 + (t1-z1) * b11
                let mut s1 = t0_min_z0;
                b01_copy.copy_from_slice(b01);
                poly_mul_fft(LOGN_U32, &mut s1, &b01_copy);
                let mut temp = t1_min_z1;
                b11_copy.copy_from_slice(b11);
                poly_mul_fft(LOGN_U32, &mut temp, &b11_copy);
                poly_add(LOGN_U32, &mut s1, &temp);

                // Compute norm ||s||² in FFT domain
                let mut length_squared = 0.0_f64;
                for i in 0..(N / 2) {
                    let s0_re = s0[i].to_f64();
                    let s0_im = s0[i + N / 2].to_f64();
                    let s1_re = s1[i].to_f64();
                    let s1_im = s1[i + N / 2].to_f64();
                    length_squared += s0_re * s0_re + s0_im * s0_im;
                    length_squared += s1_re * s1_re + s1_im * s1_im;
                }
                length_squared /= N as f64;

                if length_squared > (SIG_L2_BOUND as f64) {
                    continue;
                }

                // Negate s0 for output format
                for i in 0..N {
                    s0[i] = -s0[i];
                }

                break [s0, s1];
            };

            // Transform s1 back to coefficient domain via inverse FFT
            let mut s2_fft = bold_s[1];
            iFFT(LOGN_U32, &mut s2_fft);

            let s2_coef: [i16; N] = s2_fft[0..N]
                .iter()
                .map(|a| (*a).to_f64().round() as i16)
                .collect::<Vec<i16>>()
                .try_into()
                .expect("The number of coefficients should be equal to N");

            if let Ok(s2) = SignaturePoly::try_from(&s2_coef) {
                return s2;
            }
        }
    }

    /// Deterministically generates a seed for seeding the PRNG used in the trapdoor sampling
    /// algorithm used during signature generation.
    ///
    /// This uses the argument described in [RFC 6979](https://datatracker.ietf.org/doc/html/rfc6979#section-3.5)
    /// § 3.5 where the concatenation of the private key and the hashed message, i.e., sk || H(m),
    /// is used in order to construct the initial seed of a PRNG. See also [1].
    ///
    ///
    /// Note that we hash in also a `log_2(N)` where `N = 512` in order to domain separate between
    /// different versions of the Falcon DSA, see [1] Section 3.4.1.
    ///
    /// [1]: https://github.com/algorand/falcon/blob/main/falcon-det.pdf
    fn generate_seed(&self, message: &Word) -> [u8; 32] {
        let mut buffer = Vec::with_capacity(1 + SK_LEN + Word::SERIALIZED_SIZE);
        buffer.push(LOG_N);
        buffer.extend_from_slice(&self.to_bytes());
        buffer.extend_from_slice(&message.to_bytes());

        let digest = Blake3_256::hash(&buffer);

        // Zeroize the buffer as it contains secret key material
        buffer.zeroize();

        digest.into()
    }
}

impl PartialEq for SecretKey {
    fn eq(&self, other: &Self) -> bool {
        use subtle::ConstantTimeEq;
        self.to_bytes().ct_eq(&other.to_bytes()).into()
    }
}

impl Eq for SecretKey {}

// SERIALIZATION / DESERIALIZATION
// ================================================================================================

impl Serializable for SecretKey {
    fn write_into<W: ByteWriter>(&self, target: &mut W) {
        let basis = &self.secret_key;

        // header
        let n = basis[0].coefficients.len();
        let l = n.checked_ilog2().unwrap() as u8;
        let header: u8 = (5 << 4) | l;

        let f = &basis[1];
        let g = &basis[0];
        let big_f = &basis[3];

        let mut buffer = Vec::with_capacity(1281);
        buffer.push(header);

        // Encode f, g, F directly without negation (matches fn-dsa format)
        let mut f_i8: Vec<i8> = f
            .coefficients
            .iter()
            .map(|&a| FalconFelt::new(a).balanced_value() as i8)
            .collect();
        let f_i8_encoded = encode_i8(&f_i8, WIDTH_SMALL_POLY_COEFFICIENT).unwrap();
        buffer.extend_from_slice(&f_i8_encoded);
        f_i8.zeroize();

        let mut g_i8: Vec<i8> = g
            .coefficients
            .iter()
            .map(|&a| FalconFelt::new(a).balanced_value() as i8)
            .collect();
        let g_i8_encoded = encode_i8(&g_i8, WIDTH_SMALL_POLY_COEFFICIENT).unwrap();
        buffer.extend_from_slice(&g_i8_encoded);
        g_i8.zeroize();

        let mut big_f_i8: Vec<i8> = big_f
            .coefficients
            .iter()
            .map(|&a| FalconFelt::new(a).balanced_value() as i8)
            .collect();
        let big_f_i8_encoded = encode_i8(&big_f_i8, WIDTH_BIG_POLY_COEFFICIENT).unwrap();
        buffer.extend_from_slice(&big_f_i8_encoded);
        big_f_i8.zeroize();

        target.write_bytes(&buffer);
        // Note: buffer is not zeroized here as it's being passed to write_bytes which consumes it
        // The caller should ensure proper handling of the written bytes
    }
}

impl Deserializable for SecretKey {
    fn read_from<R: ByteReader>(source: &mut R) -> Result<Self, DeserializationError> {
        let byte_vector: [u8; SK_LEN] = source.read_array()?;

        // read fields
        let header = byte_vector[0];

        // check fixed bits in header
        if (header >> 4) != 5 {
            return Err(DeserializationError::InvalidValue("Invalid header format".to_string()));
        }

        // check log n
        let logn = (header & 15) as usize;
        let n = 1 << logn;

        // match against const variant generic parameter
        if n != N {
            return Err(DeserializationError::InvalidValue(
                "Unsupported Falcon DSA variant".to_string(),
            ));
        }

        let chunk_size_f = ((n * WIDTH_SMALL_POLY_COEFFICIENT) + 7) >> 3;
        let chunk_size_g = ((n * WIDTH_SMALL_POLY_COEFFICIENT) + 7) >> 3;
        let chunk_size_big_f = ((n * WIDTH_BIG_POLY_COEFFICIENT) + 7) >> 3;

        let f = decode_i8(&byte_vector[1..chunk_size_f + 1], WIDTH_SMALL_POLY_COEFFICIENT).ok_or(
            DeserializationError::InvalidValue("Failed to decode f coefficients".to_string()),
        )?;
        let g = decode_i8(
            &byte_vector[chunk_size_f + 1..(chunk_size_f + chunk_size_g + 1)],
            WIDTH_SMALL_POLY_COEFFICIENT,
        )
        .unwrap();
        let big_f = decode_i8(
            &byte_vector[(chunk_size_f + chunk_size_g + 1)
                ..(chunk_size_f + chunk_size_g + chunk_size_big_f + 1)],
            WIDTH_BIG_POLY_COEFFICIENT,
        )
        .unwrap();

        let f = Polynomial::new(f.iter().map(|&c| FalconFelt::new(c.into())).collect());
        let g = Polynomial::new(g.iter().map(|&c| FalconFelt::new(c.into())).collect());
        let big_f = Polynomial::new(big_f.iter().map(|&c| FalconFelt::new(c.into())).collect());

        // big_g * f - g * big_f = p (mod X^n + 1)
        let big_g = g.fft().hadamard_div(&f.fft()).hadamard_mul(&big_f.fft()).ifft();

        // Store basis as [g, f, G, F] without negations (matches fn-dsa format)
        // Negations will be applied only during signing when needed
        let basis = [
            g.map(|f| f.balanced_value()),
            f.map(|f| f.balanced_value()),
            big_g.map(|f| f.balanced_value()),
            big_f.map(|f| f.balanced_value()),
        ];
        Ok(Self::from_short_lattice_basis(basis))
    }
}

// HELPER FUNCTIONS
// ================================================================================================

/// Computes the complex FFT of the secret key polynomials.
/// Returns [FFT(g), FFT(-f), FFT(G), FFT(-F)] for the signing basis [[g, -f], [G, -F]].
/// This is used for both the LDL tree computation and legacy signing.
fn to_complex_fft(basis: &[Polynomial<i16>; 4]) -> [Polynomial<Complex<f64>>; 4] {
    let [g, f, big_g, big_f] = basis.clone();
    let g_fft = g.map(|cc| Complex64::new(*cc as f64, 0.0)).fft();
    let minus_f_fft = f.map(|cc| -Complex64::new(*cc as f64, 0.0)).fft();
    let big_g_fft = big_g.map(|cc| Complex64::new(*cc as f64, 0.0)).fft();
    let minus_big_f_fft = big_f.map(|cc| -Complex64::new(*cc as f64, 0.0)).fft();
    [g_fft, minus_f_fft, big_g_fft, minus_big_f_fft]
}

/// Encodes a sequence of signed integers such that each integer x satisfies |x| < 2^(bits-1)
/// for a given parameter bits. bits can take either the value 6 or 8.
#[allow(dead_code)]
pub fn encode_i8_legacy(x: &[i8], bits: usize) -> Option<Vec<u8>> {
    let maxv = (1 << (bits - 1)) - 1_usize;
    let maxv = maxv as i8;
    let minv = -maxv;

    for &c in x {
        if c > maxv || c < minv {
            return None;
        }
    }

    let out_len = ((N * bits) + 7) >> 3;
    let mut buf = vec![0_u8; out_len];

    let mut acc = 0_u32;
    let mut acc_len = 0;
    let mask = ((1_u16 << bits) - 1) as u8;

    let mut input_pos = 0;
    for &c in x {
        acc = (acc << bits) | (c as u8 & mask) as u32;
        acc_len += bits;
        while acc_len >= 8 {
            acc_len -= 8;
            buf[input_pos] = (acc >> acc_len) as u8;
            input_pos += 1;
        }
    }
    if acc_len > 0 {
        buf[input_pos] = (acc >> (8 - acc_len)) as u8;
    }

    Some(buf)
}

/// Decodes a sequence of bytes into a sequence of signed integers such that each integer x
/// satisfies |x| < 2^(bits-1) for a given parameter bits. bits can take either the value 6 or 8.
#[allow(dead_code)]
pub fn decode_i8_legacy(buf: &[u8], bits: usize) -> Option<Vec<i8>> {
    let mut x = [0_i8; N];

    let mut i = 0;
    let mut j = 0;
    let mut acc = 0_u32;
    let mut acc_len = 0;
    let mask = (1_u32 << bits) - 1;
    let a = (1 << bits) as u8;
    let b = ((1 << (bits - 1)) - 1) as u8;

    while i < N {
        acc = (acc << 8) | (buf[j] as u32);
        j += 1;
        acc_len += 8;

        while acc_len >= bits && i < N {
            acc_len -= bits;
            let w = (acc >> acc_len) & mask;

            let w = w as u8;

            let z = if w > b { w as i8 - a as i8 } else { w as i8 };

            x[i] = z;
            i += 1;
        }
    }

    if (acc & ((1u32 << acc_len) - 1)) == 0 {
        Some(x.to_vec())
    } else {
        None
    }
}

/// Encodes a slice of i8 values using fn-dsa-comm's trim encoding.
pub fn encode_i8(x: &[i8], bits: usize) -> Option<Vec<u8>> {
    let out_len = ((x.len() * bits) + 7) >> 3;
    let mut buf = vec![0_u8; out_len];
    let written = fn_dsa_comm::codec::trim_i8_encode(x, bits as u32, &mut buf);
    if written == out_len { Some(buf) } else { None }
}

/// Decodes a buffer into a slice of i8 values using fn-dsa-comm's trim decoding.
pub fn decode_i8(buf: &[u8], bits: usize) -> Option<Vec<i8>> {
    let mut x = vec![0_i8; N];
    fn_dsa_comm::codec::trim_i8_decode(buf, &mut x, bits as u32)?;
    Some(x)
}
