use alloc::{string::ToString, vec::Vec};

use fn_dsa_comm::mq;
use fn_dsa_kgen::{FN_DSA_LOGN_512, KeyPairGenerator, KeyPairGenerator512};
use miden_crypto_derive::{SilentDebug, SilentDisplay};
use rand::{CryptoRng, Rng, RngCore};

use super::{
    super::{
        ByteReader, ByteWriter, Deserializable, DeserializationError, N, Nonce, Serializable,
        ShortLatticeBasis, Signature,
        math::{FalconFelt, Polynomial, flr::FLR},
        signature::SignaturePoly,
    },
    PublicKey,
};
use crate::{
    Word,
    dsa::falcon512_rpo::{LOG_N, PK_LEN, SK_LEN, hash_to_point::hash_to_point_rpo256},
    utils::zeroize::{Zeroize, ZeroizeOnDrop},
};

// CONSTANTS
// ================================================================================================

pub(crate) const WIDTH_BIG_POLY_COEFFICIENT: usize = 8;
pub(crate) const WIDTH_SMALL_POLY_COEFFICIENT: usize = 6;

// SECRET KEY
// ================================================================================================

/// Represents the secret key for Falcon DSA.
///
/// The secret key is stored internally as a quadruple [g, f, G, F] of polynomials with integer
/// coefficients. During signing, this is transformed to the signing basis [[g, -f], [G, -F]] where
/// negations are applied. Each polynomial is of degree at most N = 512 and computations with these
/// polynomials is done modulo the monic irreducible polynomial ϕ = x^N + 1. The secret key is a
/// basis for a lattice and has the property of being short with respect to a certain norm and an
/// upper bound appropriate for a given security parameter. The public key on the other hand is
/// another basis for the same lattice and can be described by a single polynomial h with integer
/// coefficients modulo ϕ. The two keys are related by the following relation:
///
/// 1. h = g /f [mod ϕ][mod p]
/// 2. f.G - g.F = p [mod ϕ]
///
/// where p = 12289 is the Falcon prime. Equation 2 is called the NTRU equation.
/// The secret key is generated by first sampling a random pair (f, g) of polynomials using
/// an appropriate distribution that yields short but not too short polynomials with integer
/// coefficients modulo ϕ. The NTRU equation is then used to find a matching pair (F, G).
/// The public key is then derived from the secret key using equation 1.
///
/// To allow for fast signature generation, the secret key basis is precomputed in FFT format
/// during keygen. During signing, the Gram matrix is computed from this FFT basis, and then
/// the LDL decomposition is computed on-the-fly for fast sampling of short vectors using the
/// Fast Fourier sampling algorithm (ffSampling algorithm 11 in [1]).
///
/// [1]: https://falcon-sign.info/falcon.pdf
#[derive(Clone, SilentDebug, SilentDisplay)]
pub struct SecretKey {
    secret_key: ShortLatticeBasis,
    /// Precomputed basis B = [[g, -f], [G, -F]] in FFT format using FLR arithmetic.
    /// This is used for fast signing with the FLR-based sampler.
    /// Layout: [b00, b01, b10, b11] where each is N FLR values in FFT domain.
    basis_fft_flr: [FLR; 4 * N],
}

impl Zeroize for SecretKey {
    fn zeroize(&mut self) {
        self.secret_key.zeroize();
        // Manually zeroize FLR array
        for i in 0..self.basis_fft_flr.len() {
            self.basis_fft_flr[i] = FLR::ZERO;
        }
    }
}

// Manual Drop implementation to ensure zeroization on drop.
impl Drop for SecretKey {
    fn drop(&mut self) {
        self.zeroize();
    }
}

impl ZeroizeOnDrop for SecretKey {}

#[allow(clippy::new_without_default)]
impl SecretKey {
    // CONSTRUCTORS
    // --------------------------------------------------------------------------------------------

    /// Generates a secret key from OS-provided randomness.
    #[cfg(feature = "std")]
    pub fn new() -> Self {
        let mut rng = rand::rng();
        Self::with_rng(&mut rng)
    }

    /// Generates a secret_key using the provided random number generator `Rng`.
    ///
    /// # Security Requirements
    ///
    /// The provided RNG must be cryptographically secure. Using a weak or predictable
    /// RNG will completely compromise security. Prefer [`SecretKey::new()`] which uses
    /// OS-provided randomness unless you have specific requirements for the RNG source.
    pub fn with_rng<R: RngCore + CryptoRng>(rng: &mut R) -> Self {
        let mut kg = KeyPairGenerator512::default();
        let mut sign_key = [0u8; SK_LEN];
        let mut vrfy_key = [0u8; PK_LEN];

        // Bridge our rand 0.9 RNG into fn-dsa's rand_core 0.6 traits expected by keygen.
        let mut adapter = FnDsaRng { rng };
        kg.keygen(FN_DSA_LOGN_512, &mut adapter, &mut sign_key, &mut vrfy_key);

        let sk = SecretKey::read_from_bytes(&sign_key)
            .expect("fn-dsa-kgen produced an invalid signing key");

        // Zeroize key buffers to prevent leakage
        sign_key.zeroize();
        vrfy_key.zeroize();

        sk
    }

    /// Given a short basis [g, f, G, F], precomputes the FLR basis in FFT format.
    /// Note: The basis is stored as [g, f, G, F]; negations to form [[g, -f], [G, -F]] are
    /// applied during FLR basis computation.
    pub(crate) fn from_short_lattice_basis(basis: ShortLatticeBasis) -> SecretKey {
        // Precompute FLR basis in FFT format for fast signing
        let basis_fft_flr = Self::compute_basis_fft_flr(&basis);

        Self { secret_key: basis, basis_fft_flr }
    }

    // PUBLIC ACCESSORS
    // --------------------------------------------------------------------------------------------

    /// Returns the polynomials of the short lattice basis of this secret key.
    pub fn short_lattice_basis(&self) -> &ShortLatticeBasis {
        &self.secret_key
    }

    /// Returns the public key corresponding to this secret key.
    pub fn public_key(&self) -> PublicKey {
        self.compute_pub_key_poly()
    }

    // SIGNATURE GENERATION
    // --------------------------------------------------------------------------------------------

    /// Signs a message with this secret key using deterministic signing.
    ///
    /// The signing seed is derived from the message and secret key using BLAKE3,
    /// ensuring the same message always produces the same signature.
    pub fn sign(&self, message: Word) -> Signature {
        let mut seed = self.generate_signing_seed(&message);
        let sig = self.sign_with_seed(message, &seed);
        seed.zeroize();
        sig
    }

    /// Signs a message with the secret key using the provided randomness generator.
    ///
    /// The RNG is used to generate the 56-byte seed for the internal SHAKE256 PRNG.
    pub fn sign_with_rng<R: Rng>(&self, message: Word, rng: &mut R) -> Signature {
        let mut seed = [0u8; 56];
        rng.fill_bytes(&mut seed);
        let sig = self.sign_with_seed(message, &seed);
        seed.zeroize();
        sig
    }

    /// Signs a message using the provided 56-byte seed for the PRNG.
    fn sign_with_seed(&self, message: Word, seed: &[u8; 56]) -> Signature {
        use fn_dsa_comm::shake::SHAKE256_PRNG;

        let nonce = Nonce::deterministic();
        let h = self.compute_pub_key_poly();
        let c = hash_to_point_rpo256(message, &nonce);
        let s2 = self.sign_helper::<SHAKE256_PRNG>(c, seed);

        Signature::new(nonce, h, s2)
    }

    /// Signs a byte message using SHAKE256 hash-to-point with a random nonce.
    ///
    /// This produces signatures that match fn-dsa 1-to-1, using:
    /// - SHAKE256-based hash-to-point (original Falcon)
    /// - Random 40-byte nonce from the provided RNG
    /// - SHAKE256 PRNG for Gaussian sampling
    ///
    /// Returns a tuple of (nonce, s2_coefficients) representing the raw signature components.
    /// These can be encoded into fn-dsa's signature format if needed.
    ///
    /// # Parameters
    /// - `message`: The byte message to sign
    /// - `rng`: Random number generator for nonce and PRNG seed generation
    ///
    /// # Returns
    /// A tuple containing:
    /// - `nonce`: The 40-byte random nonce used in signing
    /// - `s2`: The signature polynomial coefficients as i16 values
    pub fn sign_shake256<R: Rng>(&self, message: &[u8], rng: &mut R) -> ([u8; 40], [i16; N]) {
        use fn_dsa_comm::shake::SHAKE256_PRNG;

        // Generate random 40-byte nonce
        let mut nonce = [0u8; 40];
        rng.fill_bytes(&mut nonce);

        // Generate random 56-byte seed for PRNG
        let mut seed = [0u8; 56];
        rng.fill_bytes(&mut seed);

        let s2 = self.sign_shake256_inner::<SHAKE256_PRNG>(message, &nonce, &seed);

        // Zeroize seed
        seed.zeroize();

        (nonce, s2)
    }

    /// Inner implementation for SHAKE256 hash-to-point signing.
    ///
    /// Generic over PRNG type to support both production use (SHAKE256_PRNG) and
    /// KAT testing (ChaCha20PRNG to match the C reference implementation).
    pub(crate) fn sign_shake256_inner<P: fn_dsa_comm::PRNG>(
        &self,
        message: &[u8],
        nonce: &[u8; 40],
        seed: &[u8; 56],
    ) -> [i16; N] {
        use fn_dsa_comm::{DOMAIN_NONE, HASH_ID_ORIGINAL_FALCON, shake::SHAKE256};

        // Compute hvk = SHAKE256(verification_key)
        let pk = self.compute_pub_key_poly();
        let vk_bytes = (&pk).to_bytes();
        let mut hvk = [0u8; 64];
        {
            let mut sh = SHAKE256::new();
            sh.inject(&vk_bytes);
            sh.flip();
            sh.extract(&mut hvk);
        }

        // Compute hash-to-point using SHAKE256 (original Falcon)
        let mut hm = [0u16; N];
        fn_dsa_comm::hash_to_point(nonce, &hvk, &DOMAIN_NONE, &HASH_ID_ORIGINAL_FALCON, message, &mut hm);

        // Convert hm to FalconFelt polynomial for sign_helper
        let c = Polynomial::new(hm.iter().map(|&v| FalconFelt::new(v)).collect());

        // Sign using the internal helper with the specified PRNG type
        let s2_poly = self.sign_helper::<P>(c, seed);

        // Convert SignaturePoly to i16 array
        core::array::from_fn(|i| s2_poly.coefficients[i].balanced_value())
    }

    // HELPER METHODS
    // --------------------------------------------------------------------------------------------

    /// Derives the public key corresponding to this secret key using fn-dsa's mq NTT
    /// (computes h = g / f [mod ϕ][mod p]).
    fn compute_pub_key_poly(&self) -> PublicKey {
        const LOGN_U32: u32 = LOG_N as u32;

        let mut h = [0u16; N];
        let mut tmp = [0u16; N];
        // basis layout: [g, f, G, F]
        let f = &self.secret_key[1].coefficients;
        let g = &self.secret_key[0].coefficients;
        mq::mqpoly_div_small(LOGN_U32, f, g, &mut h, &mut tmp);

        let pk = Polynomial::from_u16_ext_array(&h).into();

        // Zeroize temporaries holding secret-derived values
        h.fill(0);
        tmp.fill(0);

        pk
    }

    /// Signs a message polynomial with the secret key using FLR-based ffsampling.
    ///
    /// This is a thin wrapper around `fn_dsa_sign::sign_core::sign_poly` which handles
    /// the Gaussian sampling and norm bound checking. This implementation uses Fixed-point
    /// Linear Real (FLR) arithmetic from rust-fn-dsa, providing deterministic, no_std
    /// compatible signing without requiring floating-point hardware.
    ///
    /// Takes a 56-byte seed and message polynomial representing `c` the hash-to-point of the
    /// message to be signed. It outputs a signature polynomial `s2`.
    pub(crate) fn sign_helper<P: fn_dsa_comm::PRNG>(
        &self,
        c: Polynomial<FalconFelt>,
        seed: &[u8; 56],
    ) -> SignaturePoly {
        use fn_dsa_sign::{flr::FLR as FnFLR, sign_core::sign_poly};
        const LOGN_U32: u32 = LOG_N as u32;

        // Convert hash-to-point polynomial to u16 coefficients
        let hm: Vec<u16> = c.coefficients.iter().map(|f| f.value()).collect();

        // Allocate temporary buffer (sign_poly requires at least 9*N FLR elements)
        let mut tmp = vec![FnFLR::ZERO; 9 * N];

        // Call sign_poly which handles sampling, norm checking, and retry loop
        let s2_vec = sign_poly::<P>(LOGN_U32, &hm, seed, &self.basis_fft_flr, &mut tmp);

        // Zeroize temporary buffer
        tmp.zeroize();

        // Convert to SignaturePoly
        let s2_coef: [i16; N] = s2_vec
            .try_into()
            .expect("sign_poly returns exactly N coefficients");

        SignaturePoly::try_from(&s2_coef)
            .expect("signature from sign_poly should be valid; norm was already checked")
    }

    /// Computes the FLR basis B = [[g, -f], [G, -F]] in FFT format.
    /// Returns an array [b00, b01, b10, b11] where each is N FLR values in FFT domain.
    fn compute_basis_fft_flr(basis: &ShortLatticeBasis) -> [FLR; 4 * N] {
        let mut result = [FLR::ZERO; 4 * N];

        // basis is stored as [g, f, G, F]
        let g = &basis[0].coefficients;
        let f = &basis[1].coefficients;
        let big_g = &basis[2].coefficients;
        let big_f = &basis[3].coefficients;

        fn_dsa_sign::compute_basis_inner(LOG_N as u32, f, g, big_f, big_g, &mut result);

        result
    }

    /// Deterministically generates a seed for seeding the PRNG used in the trapdoor sampling
    /// algorithm used during signature generation.
    ///
    /// This uses the argument described in [RFC 6979](https://datatracker.ietf.org/doc/html/rfc6979#section-3.5)
    /// § 3.5 where the concatenation of the private key and the hashed message, i.e., sk || H(m),
    /// is used in order to construct the initial seed of a PRNG. See also [1].
    ///
    ///
    /// Note that we hash in also a `log_2(N)` where `N = 512` in order to domain separate between
    /// different versions of the Falcon DSA, see [1] Section 3.4.1.
    ///
    /// [1]: https://github.com/algorand/falcon/blob/main/falcon-det.pdf
    /// Generates a 56-byte signing seed from the message and secret key.
    ///
    /// This uses BLAKE3 in XOF mode to produce a deterministic seed for the
    /// SHAKE256 PRNG used in signing.
    fn generate_signing_seed(&self, message: &Word) -> [u8; 56] {
        let mut hasher = blake3::Hasher::new();
        hasher.update(&[LOG_N]);
        hasher.update(&self.to_bytes());
        hasher.update(&message.to_bytes());

        let mut seed = [0u8; 56];
        hasher.finalize_xof().fill(&mut seed);

        seed
    }
}

impl PartialEq for SecretKey {
    fn eq(&self, other: &Self) -> bool {
        use subtle::ConstantTimeEq;
        self.to_bytes().ct_eq(&other.to_bytes()).into()
    }
}

impl Eq for SecretKey {}

// SERIALIZATION / DESERIALIZATION
// ================================================================================================

impl Serializable for SecretKey {
    fn write_into<W: ByteWriter>(&self, target: &mut W) {
        let basis = &self.secret_key;

        // Header byte format: high nibble = 0101 (5) indicates signing key with trim encoding,
        // low nibble = log2(N) = 9 for Falcon-512. See fn-dsa specification.
        let header: u8 = (5 << 4) | LOG_N;

        let f = &basis[1];
        let g = &basis[0];
        let big_f = &basis[3];

        let mut buffer = Vec::with_capacity(SK_LEN);
        buffer.push(header);

        // Coefficients are already i8 values from ShortLatticeBasis
        // Encoding can only fail if the output buffer is incorrectly sized, which cannot
        // happen since encode_i8 allocates the buffer internally based on input length
        let mut f_i8_encoded = encode_i8(&f.coefficients, WIDTH_SMALL_POLY_COEFFICIENT)
            .expect("encoding cannot fail with correctly-sized internally-allocated buffer");
        buffer.extend_from_slice(&f_i8_encoded);
        f_i8_encoded.zeroize();

        let mut g_i8_encoded = encode_i8(&g.coefficients, WIDTH_SMALL_POLY_COEFFICIENT)
            .expect("encoding cannot fail with correctly-sized internally-allocated buffer");
        buffer.extend_from_slice(&g_i8_encoded);
        g_i8_encoded.zeroize();

        let mut big_f_i8_encoded = encode_i8(&big_f.coefficients, WIDTH_BIG_POLY_COEFFICIENT)
            .expect("encoding cannot fail with correctly-sized internally-allocated buffer");
        buffer.extend_from_slice(&big_f_i8_encoded);
        big_f_i8_encoded.zeroize();

        target.write_bytes(&buffer);

        // Zeroize buffer
        buffer.zeroize();
    }
}

impl Deserializable for SecretKey {
    fn read_from<R: ByteReader>(source: &mut R) -> Result<Self, DeserializationError> {
        let byte_vector: [u8; SK_LEN] = source.read_array()?;

        // Decode using fn-dsa's decode_inner which handles f, g, F decoding and G computation
        let mut f = [0i8; N];
        let mut g = [0i8; N];
        let mut big_f = [0i8; N];
        let mut big_g = [0i8; N];
        let mut vrfy_key = [0u8; PK_LEN];
        let mut hashed_vrfy_key = [0u8; 64];
        let mut tmp = [0u16; 2 * N];

        let logn = fn_dsa_sign::decode_inner(
            LOG_N as u32,
            LOG_N as u32,
            &mut f,
            &mut g,
            &mut big_f,
            &mut big_g,
            &mut vrfy_key,
            &mut hashed_vrfy_key,
            &mut tmp,
            &byte_vector,
        )
        .ok_or(DeserializationError::InvalidValue(
            "Failed to decode secret key".to_string(),
        ))?;

        if logn != LOG_N as u32 {
            return Err(DeserializationError::InvalidValue(
                "Unsupported Falcon DSA variant".to_string(),
            ));
        }

        // Zeroize temporaries
        tmp.fill(0);
        hashed_vrfy_key.fill(0);

        // Store basis as [g, f, G, F]
        let basis = [
            Polynomial::new(g.to_vec()),
            Polynomial::new(f.to_vec()),
            Polynomial::new(big_g.to_vec()),
            Polynomial::new(big_f.to_vec()),
        ];
        Ok(Self::from_short_lattice_basis(basis))
    }
}

// HELPER FUNCTIONS
// ================================================================================================

/// Computes the number of bytes needed to store `num_bits` bits, rounding up.
///
/// This is equivalent to ceiling division: `(num_bits + 7) / 8`.
#[inline]
const fn bits_to_bytes_ceil(num_bits: usize) -> usize {
    (num_bits + 7) >> 3
}

/// Encodes a slice of i8 values using fn-dsa-comm's trim encoding.
///
/// # Returns
/// - `Some(Vec<u8>)` containing the encoded bytes if successful
/// - `None` if encoding fails (buffer size mismatch)
///
/// # Security Note
/// When encoding secret key material, the caller is responsible for zeroizing
/// the returned buffer after use. The buffer contains a copy of the input data
/// in encoded form.
pub fn encode_i8(x: &[i8], bits: usize) -> Option<Vec<u8>> {
    let out_len = bits_to_bytes_ceil(x.len() * bits);
    let mut buf = vec![0_u8; out_len];
    let written = fn_dsa_comm::codec::trim_i8_encode(x, bits as u32, &mut buf);
    if written == out_len { Some(buf) } else { None }
}

/// Adapts a rand 0.9 RNG to the rand_core 0.6 traits expected by fn-dsa keygen.
struct FnDsaRng<'a, R: RngCore + CryptoRng> {
    rng: &'a mut R,
}

impl<'a, R: RngCore + CryptoRng> fn_dsa_comm::RngCore for FnDsaRng<'a, R> {
    fn next_u32(&mut self) -> u32 {
        self.rng.next_u32()
    }

    fn next_u64(&mut self) -> u64 {
        self.rng.next_u64()
    }

    fn fill_bytes(&mut self, dest: &mut [u8]) {
        self.rng.fill_bytes(dest);
    }

    fn try_fill_bytes(
        &mut self,
        dest: &mut [u8],
    ) -> core::result::Result<(), fn_dsa_comm::RngError> {
        self.fill_bytes(dest);
        Ok(())
    }
}

impl<'a, R: RngCore + CryptoRng> fn_dsa_comm::CryptoRng for FnDsaRng<'a, R> {}
