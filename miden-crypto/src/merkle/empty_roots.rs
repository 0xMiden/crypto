use core::slice;

use super::{Felt, Word, smt::InnerNode};

// EMPTY NODES SUBTREES
// ================================================================================================

/// Contains precomputed roots of empty subtrees in a Merkle tree.
pub struct EmptySubtreeRoots;

impl EmptySubtreeRoots {
    /// Returns a static slice with roots of empty subtrees of a Merkle tree starting at the
    /// specified depth.
    pub const fn empty_hashes(tree_depth: u8) -> &'static [Word] {
        let ptr = &EMPTY_SUBTREES[255 - tree_depth as usize] as *const Word;
        // Safety: this is a static/constant array, so it will never be outlived. If we attempt to
        // use regular slices, this wouldn't be a `const` function, meaning we won't be able to use
        // the returned value for static/constant definitions.
        unsafe { slice::from_raw_parts(ptr, tree_depth as usize + 1) }
    }

    /// Returns the node's digest for a sub-tree with all its leaves set to the empty word.
    pub const fn entry(tree_depth: u8, node_depth: u8) -> &'static Word {
        assert!(node_depth <= tree_depth);
        let pos = 255 - tree_depth + node_depth;
        &EMPTY_SUBTREES[pos as usize]
    }

    /// Returns a sparse Merkle tree [`InnerNode`] with two empty children.
    ///
    /// # Note
    /// `node_depth` is the depth of the **parent** to have empty children. That is, `node_depth`
    /// and the depth of the returned [`InnerNode`] are the same, and thus the empty hashes are for
    /// subtrees of depth `node_depth + 1`.
    pub(crate) const fn get_inner_node(tree_depth: u8, node_depth: u8) -> InnerNode {
        let &child = Self::entry(tree_depth, node_depth + 1);
        InnerNode { left: child, right: child }
    }
}

// Poseidon2 empty subtree hashes for depths 0..255 (root at index 0). Generated by repeatedly
// merging the empty word upward.
const EMPTY_SUBTREES: [Word; 256] = include!("empty_subtrees_poseidon2.inc.rs");

// TESTS
// ================================================================================================

#[cfg(test)]
mod tests {
    use super::{
        super::{EMPTY_WORD, Poseidon2},
        EMPTY_SUBTREES, EmptySubtreeRoots,
    };

    #[test]
    fn all_depths_opens_to_zero() {
        // assert the length of the static constants is correct and will cover every possible depth
        assert!(EMPTY_SUBTREES.len() > u8::MAX as usize);

        for depth in 0..=u8::MAX {
            // fetch the subtrees and reverse it so the path is leaf -> root
            let mut subtree = EmptySubtreeRoots::empty_hashes(depth).to_vec();
            subtree.reverse();

            // the length of the subtrees set must be equal to depth + 1 as we also
            // include the root
            assert_eq!(depth as usize + 1, subtree.len());

            // assert the opening is zero
            let initial = EMPTY_WORD;
            assert_eq!(initial, subtree.remove(0));

            // compute every node of the path manually and compare with the output
            subtree
                .into_iter()
                .scan(initial, |state, x| {
                    *state = Poseidon2::merge(&[*state; 2]);
                    Some((x, *state))
                })
                .for_each(|(x, computed)| assert_eq!(x, computed));
        }
    }

    #[test]
    fn test_entry() {
        // check the leaf is always the empty work
        for depth in 0..255 {
            assert_eq!(EmptySubtreeRoots::entry(depth, depth), &EMPTY_WORD);
        }

        // check the root matches the first element of empty_hashes
        for depth in 0..255 {
            assert_eq!(
                EmptySubtreeRoots::entry(depth, 0),
                &EmptySubtreeRoots::empty_hashes(depth)[0]
            );
        }
    }
}
